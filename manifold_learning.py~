from time import time
import numpy as np
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D
from matplotlib.ticker import NullFormatter
from sklearn import manifold
from sklearn.utils import check_random_state
from tqdm import tqdm
from scipy.spatial import distance

# Next line to silence pyflakes.
Axes3D

# Variables for manifold learning.
n_neighbors = 10
n_samples = 1000


def load() :
    data = np.load("data.npz")
    data.allow_pickle = True
    return data["x"], data["y"]


sound, data = load()
data = data[:300]
sound = sound[:300]


def display(n) :
    m = manifold.SpectralEmbedding(n)
    d = m.fit_transform(data).T
    fig = plt.figure()
    ax = fig.add_subplot(111, projection='3d')
    ax.scatter(d[0], d[1], d[2], c=sound, cmap=plt.cm.spring) #cm.afmhot nice too
    plt.show()
    return 

def displayArr(d) :
    fig = plt.figure()
    ax = fig.add_subplot(111, projection='3d')
    ax.scatter(d[0], d[1], d[2], c=sound, cmap=plt.cm.spring) #cm.afmhot nice too
    plt.show()
    return 

def getMatrix(d) :
    mat = distance.cdist(d, d)
    m = np.max(mat)*10
    matrix = np.ones(mat.shape) * m
    return matrix-mat


def getMatrix0(d) :
    mat = distance.cdist(d, d)
    m = np.max(mat)
    for i in range(len(mat)) :
        for j in range(len(mat[0])) :
            mat[i][j] = m - mat[i][j]
    return mat

def compare() :
    tprint0, tprint1, tprint2, tprint3 = 0,0,0,0
    for i in tqdm(range(20)) :
        m0, m1 = manifold.SpectralEmbedding(3), manifold.SpectralEmbedding(3, affinity='precomputed')
        t0 = time()
        m0.fit_transform(data)
        t1 = time()
        tprint0 += t1-t0
        t0 = time()
        mat = getMatrix(data)
        t1 = time()
        m1.fit_transform(mat)
        t2 = time()
        tprint1 += t1-t0
        tprint2 += t2-t1
        tprint3 += t2-t0
    print("First method : " + str(tprint0/20))
    print("Second method :")
    print("\t mat : " + str(tprint1/20))
    print("\t fitting : " + str(tprint2/20))
    print("\t total : " + str(tprint3/20))
    return 



def getFitTime(l) :
    r = 0
    if (l < 1) :
        return 0
    for i in range(5) :
        try :
            m = manifold.SpectralEmbedding(3, affinity='precomputed')
            _, d = load()
            mat = getMatrix(d[:int(l)])
            t0 = time()
            max=np.max(mat)
            m.fit_transform(mat)
            t1 = time()
            r += (t1-t0)
        except :
            return 0
    return (r/5)


def getUndersamplingRate(t, l,h, p=0.001) :
    c = getFitTime(int(h-l)/2)
    if (c==0) :
        print("No solution found")
        return
    print(str(c) + '\t' + str(h) + '\t' + str(l))
    if (abs(c - t) <= p) :
        return l
    if (c >= t) :
        return getUndersamplingRate(t, l, l+int(h-l)/2)
    if (c < t):
        return getUndersamplingRate(t, l+int(h-l)/2, h)
    
